{
  "name": "Sky",
  "tagline": "Functional programming utilities for elixir",
  "body": "# Sky\r\n\r\n[![Build Status](https://travis-ci.org/aleandros/sky.svg?branch=master)](https://travis-ci.org/aleandros/sky)\r\n\r\nA small set of functions for manipulation functions in elixir.\r\n\r\n## Rationale\r\n\r\nThe pipe operator is probably one of the coolest features of the language. While\r\nnot exclusive to elixir, it's a core part of writing readable programs. You just\r\nbegin with your data and transform it step by step.\r\n\r\nBut Elixir is functional. Functions are data too. Why not transforming them as we see fit?\r\nThis small collection of functions attempts to provide a way to do just that.\r\n\r\nOne important aspect of this library is that it tries to be useful as much as it\r\nis intended to be fun thought experiment. That's why everything is provided with\r\nfunctions instead of macros. Why? Maybe I'm not smart enough for macros. But also\r\nI believe that we can go a long, long way without them.\r\n\r\n## Examples\r\n\r\nYou can find more of these in the documentation or in the tests, but let's\r\nbegin with a simple one:\r\n\r\n```elixir\r\nsafe_float_div = \r\n  fn(a, b) -> a / b end\r\n  |> Sky.tupleize\r\n  |> Sky.noraise\r\n\r\nsafe_float_div.({1, 0})\r\n# => {:error, %ArithmeticError{message: \"bad argument in arithmetic expression\"}}\r\n\r\nsafe_float_div.({1, 2})\r\n# => {:ok, 0.5}\r\n```\r\n\r\nThe idea is to create more sophisticated functions without complicated branching\r\nthat distracts us from our original intent.\r\n\r\nLet's look at something more interesting. The square root of a number is not defined\r\nfor negative numbers, and the logarithm is undefined for non-positive numbers\r\n(negative numbers and zero). How could we take our arithmetic functions and make\r\nthem safe, yet leave our code free of conditionals and unnecessary pattern matching?\r\n\r\n```elixir\r\nlift_predicate =\r\n  (&Sky.reject_if/2)\r\n  |> Sky.swap\r\n  |> Sky.curry\r\n\r\nnon_negative? = fn x -> x >= 0 end\r\n\r\nlift_positive = lift_predicate.(non_negative?)\r\nsafe_sqrt = lift_positive.(&:math.sqrt/1)\r\n\r\nsafe_sqrt.(9)  # => {:ok, 3.0}\r\nsafe_sqrt.(-1) # => :error\r\n```\r\nNow let's reuse our `lift_predicate` function to do something a the non-zero numbers.\r\n\r\n```elixir\r\nlift_non_zero = lift_predicate.(fn n -> n != 0 end)\r\nsafe_log = lift_non_zero.(&:math.log/1)\r\n\r\nsafe_log.(1) # => {:ok, 0.0}\r\nsafe_log.(0) # => :error\r\n```\r\n\r\n## Gotchas\r\n\r\nThere are probably missing functions and possible use patterns that can arise\r\nif this thing is used in more realistic environments.\r\n\r\nAlso, modifying functions through piping, while powerful, can probably get unreadable\r\npretty soon, so piping functions through the Sky API probably should be done in small\r\nsteps.\r\n\r\nAnother important thing is that when we create anonymous functions and bind them\r\nto variables, the syntax for using them in pipes is kind of clunky.\r\n\r\n```elixir\r\ninc = fn x -> x + 1 end\r\nx = 1 |> inc.() |> inc.()\r\n```\r\n\r\n## Installation\r\n\r\nIf [available in Hex](https://hex.pm/docs/publish), the package can be installed as:\r\n\r\n  1. Add `sky` to your list of dependencies in `mix.exs`:\r\n\r\n```elixir\r\ndef deps do\r\n  [{:sky, \"~> 0.1.0\"}]\r\nend\r\n```\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}